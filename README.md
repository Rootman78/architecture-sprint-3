## Спринт 3: Создание микросервисов, построение пайплайна CI/CD

## Условие

В этом спринте вы будете работать над кейсом компании «Тёплый дом».
О компании
«Тёплый дом» — это небольшая компания, которая организует удалённое управление отоплением в доме. Недавно она выиграла тендер и получила заказ на создание экосистемы умных посёлков на территории нескольких регионов страны.
Чтобы выполнить заказ, компании необходимо расширить функционал своей системы и масштабировать её. Экосистема должна позволить пользователям управлять не только  отоплением, но и умными устройствами в доме. Чтобы подключить дом к экосистеме, пользователям необходимо установить специальные датчики и реле. Сейчас они есть только в половине домов, которые хотят подключиться.
Состояние компании в настоящий момент не позволяет в полной мере реализовать новые бизнес-цели. Для этого требуется пересмотр и оптимизация всей экосистемы.
1. Текущее решение
Нынешнее приложение компании позволяет только управлять отоплением в доме и проверять температуру.
Каждая установка сопровождается выездом специалиста по подключению системы отопления в доме к текущей версии системы.
Архитектура приложения представляет из себя монолит на Java с СУБД Postgres. Всё синхронно. Никаких асинхронных вызовов, микросервисов и реактивного взаимодействия в системе нет. Всё управление идёт от сервера к датчику. Данные о температуре также получаются через запрос от сервера к датчику.
Самостоятельно подключить свой датчик к системе пользователь не может.
2. Целевая экосистема, которую необходимо создать
Экосистема доступна пользователю в режиме самообслуживания по модели SaaS.
Система позволяет управлять отоплением, включать и выключать свет, запирать и отпирать автоматические ворота, удалённо наблюдать за домом. Также в будущем могут появиться запросы на добавление новой функциональности. Решение должно быть легко расширяемым.
Пользователь самостоятельно выбирает необходимые ему модули умного дома (устройства), сам их подключает, настраивает сценарии работы и просматривает телеметрию.
Компания не занимается производством устройств, но поддерживает подключение к экосистеме устройств партнёров по стандартным протоколам.
Требования к экосистеме
Модули управления приборами и сами приборы (устройства) должны быть максимально готовы к использованию и продаваться в отдельных комплектах для удобной покупки и подключения.
Устройства должны быть доступны через интернет (для удалённого наблюдения и доступа). Предполагается, что пользователь будет иметь интернет-канал, к которому их можно подключить.
Покупатели могут программировать систему для управления различными модулями в соответствии со своими потребностями.
3. Лэндскейп компании
Над проектом работают:
Команда разработчиков. В ней пять человек. Они будут работать над рефакторингом и разделением монолита на микросервисы.
Команда DevOps. В ней два человека. Они будут заниматься настройкой CI/CD-пайплайнов, контейнеризацией и оркестрацией.
Команда QA. В ней три человека. Они будут проводить тестирование новой системы.
Команда по обслуживанию клиентов. Их десять человек. Этих специалистов обучат работе с новой системой, чтобы они смогли предоставлять поддержку пользователям.
Команда по продажам и маркетингу. Их пять человек. Они будут заниматься продвижением новых модульных комплектов.
Сейчас развёрнуто монолитное приложение на Java с PostgreSQL в качестве СУБД. У приложения 100 веб-клиентов, к системе подключены 100 модулей управления отоплением.
4. Цели бизнеса
Описана As-Is и To-Be архитектура решения. Создан план по переходу к целевой системе.
Разработан MVP с разделёнными микросервисами для управления отоплением, освещением, наблюдением, воротами.
Что нужно сделать
Проектная работа состоит из четырёх заданий. Последнее задание — дополнительное. Вы можете выполнить его по желанию.
В ходе работы вы проанализируете текущее монолитное приложение, выделите микросервисы и спроектируете взаимодействие между ними, визуализируете архитектуру с помощью модели С4 и разработаете ER-диаграмму. В четвёртом задании мы предложим вам спроектировать и задокументировать API микросервисов.
Какие инструменты нужны для работы
Для работы над проектом вам понадобятся:
PlantUML-редактор. Например, можете использовать PlantUML plugin for IntelliJ IDEA, online PlantUML editor или PlantUML Web Server.
Система контроля версий. Используйте GitHub — задание нужно сдать там.
IDE (например, IntelliJ IDEA, VS Code).
Markdown редактор (например, в самом IDE).
Средства для разработки API. Например, Swagger Editor.
Также вам может пригодиться:
Сайт с базой знаний по модели C4.
Документация plantUML.
Шаблон C4 для PlantUML.
Как работать над заданием
Создайте репозиторий по шаблону https://github.com/Yandex-Practicum/architecture-sprint-3.
Создайте в репозитории ветку warmhouse. В ней вы будете выполнять задания.
Выполните задания и опишите свои решения в файле Project_template. Мы заранее добавили его в репозиторий и сохранили туда шаблон для ответов. Заполняйте его по мере работы над заданиями.
Когда сделаете все задания проекта и опишете свои решения в Project_template, создайте пул-реквест из ветки warmhouse в основную ветку вашего репозитория. Убедитесь, что пул-реквест содержит все изменения, которые вы вносили. Проверьте, что отправляете их в ваш собственный репозиторий, а не в репозиторий Практикума. Это важно: если сделаете ПР в репозиторий Практикума, ревьюер сразу отправит ваше решение на доработку.
### Задание 1. Анализ и планирование

Прежде чем проектировать новую систему, необходимо досконально разобраться с тем, что у нас есть. Вам нужно изучить текущее монолитное приложение, понять его сильные и слабые стороны, а также проанализировать, как можно применить принципы Domain-Driven Design (DDD) для построения новой архитектуры.
Что нужно сделать
Изучите функциональность монолитного приложения:
Управление отоплением. Пользователи могут удалённо включать/выключать отопление в своих домах.
Мониторинг температуры. Система получает данные о температуре с датчиков, установленных в домах. Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
Проанализируйте архитектуру монолитного приложения:
Язык программирования: Java
База данных: PostgreSQL
Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
Взаимодействие: Синхронное, запросы обрабатываются последовательно.
Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
Развёртывание: Требует остановки всего приложения.
Определите домены и границы контекстов. Например, домен «Управление Устройствами» и так далее. Помимо явно подсвеченных особенностей, упомянутых выше, проанализируйте, на что ещё можно опираться из существующего решения.
Подробно опишите, какие проблемы создаёт монолитного решение для компании в контексте текущих бизнес-задач. Если вы считаете, что текущее решение не вызывает проблем, аргументируйте свою позицию.
Визуализируйте контекст системы. Создайте диаграмму контекста (Context diagram) в модели C4 с помощью PlantUML. Диаграмма должна наглядно показывать, как монолитное приложение взаимодействует с внешним миром (пользователи, датчики).
### Задание 2. Проектирование микросервисной архитектуры

Вы провели анализ текущего монолитного приложения, определили его функциональные блоки и выделили основные домены. Теперь ваша задача — спроектировать высокоуровневую архитектуру новой экосистемы, основанную на микросервисах.
Для этого вам нужно определить ключевые микросервисы и спроектировать их взаимодействие с учётом использования API Gateway и Kafka. Опционально взаимодействие между сервисами можно реализовать напрямую. Когда примите решения, визуализируйте полученную архитектуру с помощью диаграмм C4.
Что нужно сделать
Декомпозируйте приложение на микросервисы. Основывайте решение на доменах и границах контекстов, которые вы выделили в предыдущем задании, разбейте систему на новые микросервисы. При этом также учитывайте и бизнес-цели компании — они могут потребовать разработки микросервисов с нуля. У вас должны получиться домены как для As-Is решения, так и для To-Be. В ходе декомпозиции ориентируйтесь на наилучшие практики архитектуры микросервисов и паттерны проектирования.
Определите взаимодействия между:
микросервисами,
API Gateway,
шиной данных (например, Kafka), если вы решили её использовать,
базой данных.
Визуализируйте архитектуру, которая у вас получилась:
C4 — Уровень контейнеров (Containers). Создайте диаграмму, показывающую основные контейнеры (приложения, базы данных, очереди сообщений) и их взаимодействие.
C4 — Уровень компонентов (Components). Детализируйте взаимодействие внутри выбранных микросервисов, выделив ключевые компоненты и их ответственности. Например, для микросервиса «Управление устройствами» можно выделить такие компоненты: API, обработчик команд, менеджер состояния устройств.
C4 — Уровень кода (Code). Для самых критичных частей системы можете создать диаграммы на уровне кода (например, UML диаграммы классов или последовательностей), чтобы детально показать, как они реализованы. Необязательно описывать весь код — выберите только самые критичные части.
### Задание 3. Разработка ER-диаграммы

Итак, вы определили ключевые микросервисы и спроектировали их взаимодействие с использованием API Gateway и Kafka. А ещё визуализировали полученную архитектуру с помощью диаграмм C4, что позволило вам получить чёткое представление о структуре и взаимодействиях в системе.
В этом задании вам предстоит глубже погрузиться в структуру данных будущей экосистемы. Необходимо определить ключевые сущности (такие как «Устройство», «Модуль», «Пользователь», «Телеметрия») и смоделировать их взаимосвязи, чтобы создать логическую модель базы данных.
Что нужно сделать
Идентифицируйте сущности. На основе анализа предметной области и спроектированных микросервисов определите основные сущности вашей системы.

Вот несколько примеров сущностей:

Пользователь — User,
Дом — House,
Устройство — Device,
Тип устройства — DeviceType,
Модуль — Module,
Телеметрия — TelemetryData.
Определите атрибуты. Для каждой сущности определите необходимые атрибуты. Пример для сущности «Устройство»:
id — уникальный идентификатор устройства.
type_id — идентификатор типа устройства — внешний ключ к таблице DeviceType.
house_id — идентификатор дома, к которому принадлежит устройство — внешний ключ к таблице House.
serial_number — серийный номер устройства.
status — текущее состояние устройства (включено/выключено).
Опишите связи. Определите связи между сущностями (один-к-одному, один-ко-многим, многие-ко-многим).

Например:

Пользователь — Дом: один пользователь может иметь доступ к нескольким домам, но каждый дом связан только с одним пользователем.
Дом — Устройство: один дом может содержать несколько устройств, и каждое устройство принадлежит только одному дому.
Устройство — Телеметрия: одно устройство может генерировать множество записей телеметрии.
Постройте ER-диаграмму. Используйте PlantUML для создания ER-диаграммы на основе определённых сущностей, атрибутов и связей.
### Задание 4. Создание и документирование API

🔍 Это задание выполнять необязательно. Если сдадите работу без него, это не отразится на ревью.
После успешной разработки ER-диаграммы вы получили чёткое представление о структуре данных будущей экосистемы. Теперь настало время перейти к следующему этапу — созданию и документированию API.
Микросервисы должны уметь «общаться» друг с другом. Ваша задача — спроектировать 4-5 эндпоинтов API для ландшафта, который вы создали в рамках предыдущих заданий.
Вам нужно определить необходимые эндпойнты, методы запросов, форматы данных и описать контракты взаимодействия, чтобы микросервисы могли эффективно обмениваться информацией.
Что нужно сделать
Выберите типы API. В зависимости от специфики взаимодействия между вашими микросервисами, вы можете использовать:
REST API. Он хорошо подходит для синхронного взаимодействия, когда клиенту (в данном случае — другому микросервису) нужен немедленный ответ на запрос.
AsyncAPI. Его используют для асинхронного взаимодействия, когда клиенту не нужно ждать ответа немедленно (например, отправка уведомления о новом измерении температуры). Для реализации асинхронного взаимодействия можно использовать Kafka.
Спроектируйте и задокументируйте API для выбранных микросервисов. Используйте Swagger/OpenAPI (для REST API) или AsyncAPI для создания интерактивной документации. Это упростит интеграцию микросервисов и позволит другим разработчикам легко понимать, как использовать ваши API.
Что должно быть в документации API
Определите эндпойнты и методы запросов для выполнения основных операций. Например, для микросервиса «Управление устройствами», если бы выделили его на этапе декомпозиции, нужно было бы создать API для:
Получения информации об устройстве,
Обновления состояния устройства,
Отправки команды устройству.
Опишите контракты взаимодействия для API выбранных микросервисов. Для каждого эндпойнта укажите:
Формат запроса: опишите структуру JSON для тела запроса (если применимо).
Формат ответа: опишите структуру JSON для ответа.
Коды ответа: укажите HTTP-коды статуса, которые будут возвращаться в различных ситуациях (например, 200 — успех, 404 — устройство не найдено, 500 — ошибка сервера).
Примеры запросов и ответов: укажите наглядные примеры в блоке examples.

## Решение

### Задание 1 
В папке task_1

### Задание 2 
В папке task_2

### Задание 3
В папке task_3

### Задание 4
В папке task_4